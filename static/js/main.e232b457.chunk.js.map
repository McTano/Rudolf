{"version":3,"sources":["util/nodes.ts","RudolfReducer.ts","components/NodeMenu.tsx","components/FormulaView.tsx","components/Spacers.tsx","components/NodeView.tsx","components/PremiseInput.tsx","components/PremisesSelector.tsx","util/carnapAdapter.ts","components/JSONView.tsx","components/App.tsx","undoableReducer.ts","serviceWorker.ts","index.tsx"],"names":["makeNode","formulas","forest","nodeType","id","destructivelyAppendChildren","root","createNodes","length","forEach","child","console","warn","parsePremises","map","form","idx","makeTreeForm","value","row","resolved","isOpenLeaf","node","lastRow","firstRow","makeEmptyFormulas","n","nextRow","arr","push","getNode","nodePath","split","char","Number","Error","convertIdToPath","currentNode","isFormulaNode","RudolfReducer","nodeId","formulaIndex","newValue","this","draftState","tree","nodeRow","justification","Object","assign","justifications","contradictoryRows","feedback","index","draftNode","premiseArray","1","rule","parentRow","formulaCount","parentId","ImmerReducer","initialState","errorMessage","rudolfReducer","createReducerFunction","createActionCreators","continueBranch","createTree","markContradiction","markFinished","reopenBranch","splitBranch","toggleResolved","updateContradiction","updateFeedback","updateFormula","updateJustification","NodeMenu","open","dispatch","anchorEl","close","onClose","formula","Menu","MenuItem","onClick","FormulaView","useState","contextMenu","setContextMenu","ref","useRef","className","onContextMenu","e","preventDefault","onChange","event","currentTarget","placeholder","current","Check","Spacers","diff","spacers","i","key","NodeView","store","undefined","from","to","borderColor","fromAnchor","toAnchor","delay","JSON","stringify","PremiseInput","onSubmit","premises","setPremises","type","name","aria-label","target","examples","PremisesSelector","convertToSequent","newFormulas","previousFormulas","concat","label","convertFormulas","validRow","rearrangeFormulas","filter","row1","row2","every","includes","sort","a","b","form1","form2","contradictionSequent","forms","mainFormulaRow","findIndex","mainFormula","formulasWithoutMain","slice","newList","join","maybeRow","checkSequent","sequent","Promise","resolve","reject","window","Carnap","checkIchikawaJenkinsSLTableau","result","error","checkTree","feedbackTree","JSONView","useEffect","then","res","catch","message","TextareaAutosize","style","overflow","fontSize","minWidth","position","bottom","maxHeight","App","innerReducer","useReducer","action","past","present","future","previous","next","distantFuture","pastStates","currentState","futureStates","handleSubmitPremises","rawInput","IconButton","disabled","Undo","Redo","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.e232b457.chunk.js","sourcesContent":["import {\n  ContradictionNode,\n  FinishedNode,\n  FormulaNode,\n  NodeGenerator,\n  OpenLeafNode,\n  TreeForm,\n  TreeNode,\n} from '../typings/TreeState'\nimport { isNonEmptyArray } from './util'\n\nexport const makeNode = ({\n  formulas = [],\n  forest = [],\n  id,\n}: Partial<FormulaNode> & {\n  id: string\n}): FormulaNode => {\n  return {\n    nodeType: 'formulas',\n    formulas,\n    forest,\n    id,\n  }\n}\n\nexport const makeContradictionNode = (parentId: string): ContradictionNode => ({\n  nodeType: 'contradiction',\n  formulas: [],\n  contradictoryRows: '',\n  id: `${parentId}0`,\n})\n\nexport const makeFinishedNode = (parentId: string): FinishedNode => ({\n  nodeType: 'finished',\n  formulas: [],\n  id: `${parentId}0`,\n})\n\n/**\n *\n * @param root The root of a subTree\n * @param createNodes function that creates new node objects\n */\nexport const destructivelyAppendChildren = (\n  root: TreeNode,\n  createNodes: NodeGenerator\n): void => {\n  if (root.nodeType === 'contradiction') {\n    return\n  } else if (root.nodeType === 'finished') {\n    // TODO: Special Handling for FinishedNodes?\n    console.warn(\"shouldn't try to append to finished branch\")\n    return\n  } else if (root.forest.length === 0) {\n    root.forest = createNodes(root.id)\n  } else {\n    root.forest.forEach((child) =>\n      destructivelyAppendChildren(child, createNodes)\n    )\n  }\n}\n\n/**\n *\n * @param formulas an array of of formulas.\n */\nexport const parsePremises = (formulas: string[]): FormulaNode => {\n  return makeNode({\n    formulas: formulas.map((form, idx) => makeTreeForm(form, idx + 1)),\n    forest: [],\n    id: '',\n  })\n}\n\nconst makeTreeForm = (value = '', row: number): TreeForm => ({\n  value,\n  resolved: false,\n  row,\n})\n\nexport const isOpenLeaf = (node: TreeNode | null): node is OpenLeafNode =>\n  node != null && node.nodeType === 'formulas' && node.forest.length === 0\n\nexport const lastRow = (node: FormulaNode) =>\n  firstRow(node) + node.formulas.length\n\nexport const firstRow = (node: FormulaNode) => node.formulas[0].row\n\nexport const makeEmptyFormulas = (n: number, nextRow: number): TreeForm[] => {\n  const arr = []\n  while (n-- > 0) {\n    arr.push(makeTreeForm('', nextRow++))\n  }\n  return arr\n}\n\nexport const convertIdToPath = (id: string): (0 | 1)[] =>\n  id.split('').map((char: string) => {\n    if (char === '0' || char === '1') {\n      return Number(char) as 0 | 1\n    } else {\n      throw new Error(`invalid character in node id: ${char} in ${id}`)\n    }\n  })\n\nexport const getNode = (root: FormulaNode, id: string): TreeNode => {\n  const nodePath: (0 | 1)[] = convertIdToPath(id)\n  let currentNode: TreeNode = root\n  for (const idx of nodePath) {\n    if (currentNode.nodeType !== 'formulas') {\n      throw new Error('Failed to get node path')\n    }\n    currentNode = currentNode.forest[idx]\n  }\n  return currentNode\n}\n\nexport const isNonLeafNode = (\n  node: TreeNode\n): node is FormulaNode & { forest: FormulaNode[] } =>\n  isFormulaNode(node) &&\n  isNonEmptyArray(node.forest) &&\n  node.forest[0]?.nodeType === 'formulas'\n\nexport const isFormulaNode = (node: TreeNode): node is FormulaNode =>\n  node.nodeType === 'formulas'\n","import {\n  Actions,\n  createActionCreators,\n  createReducerFunction,\n  ImmerReducer,\n} from 'immer-reducer'\nimport { Dispatch } from 'react'\n\nimport {\n  FormulaNode,\n  Justification,\n  JustificationMap,\n} from './typings/TreeState'\nimport {\n  destructivelyAppendChildren,\n  getNode,\n  makeContradictionNode,\n  makeEmptyFormulas,\n  makeFinishedNode,\n  makeNode,\n  parsePremises,\n} from './util/nodes'\nimport { CheckerFeedback } from './typings/Checker'\n\nexport type RudolfStore = {\n  tree: FormulaNode\n  nextRow: number\n  justifications: JustificationMap\n  feedback: CheckerFeedback\n}\n\nexport class RudolfReducer extends ImmerReducer<RudolfStore> {\n  updateFormula(nodeId: string, formulaIndex: number, newValue: string) {\n    const draftNode = getNode(this.draftState.tree, nodeId)\n    draftNode.formulas[formulaIndex].value = newValue\n  }\n\n  updateJustification(nodeRow: number, justification: Partial<Justification>) {\n    Object.assign(this.draftState.justifications[nodeRow], justification)\n  }\n\n  updateContradiction(id: string, contradictoryRows: string) {\n    Object.assign(getNode(this.draftState.tree, id), { contradictoryRows })\n  }\n\n  updateFeedback(feedback: CheckerFeedback) {\n    this.draftState.feedback = feedback\n  }\n\n  toggleResolved(nodeId: string, index: number) {\n    const draftNode = getNode(this.draftState.tree, nodeId)\n    draftNode.formulas[index].resolved = !draftNode.formulas[index].resolved\n  }\n\n  createTree(premiseArray: string[]) {\n    this.draftState.tree = parsePremises(premiseArray)\n    this.draftState.nextRow = premiseArray.length + 1\n    this.draftState.justifications = { 1: { rule: '', parentRow: '' } }\n  }\n\n  continueBranch(nodeId: string, formulaCount: number) {\n    const draftNode = getNode(this.draftState.tree, nodeId)\n    destructivelyAppendChildren(draftNode, (id) => [\n      makeNode({\n        id: `${id}0`,\n        formulas: makeEmptyFormulas(formulaCount, this.draftState.nextRow),\n      }),\n    ])\n\n    this.draftState.justifications[this.draftState.nextRow] = {\n      rule: '',\n      parentRow: '',\n    }\n    this.draftState.nextRow += formulaCount\n  }\n\n  splitBranch(nodeId: string, formulaCount: number) {\n    const draftNode = getNode(this.draftState.tree, nodeId)\n    destructivelyAppendChildren(draftNode, (id) => {\n      const formulas = makeEmptyFormulas(formulaCount, this.draftState.nextRow)\n      return [\n        makeNode({\n          id: `${id}0`,\n          formulas,\n        }),\n        makeNode({\n          id: `${id}1`,\n          formulas,\n        }),\n      ]\n    })\n    this.draftState.justifications[this.draftState.nextRow] = {\n      rule: '',\n      parentRow: '',\n    }\n    this.draftState.nextRow += formulaCount\n  }\n\n  markContradiction(nodeId: string) {\n    const draftNode = getNode(this.draftState.tree, nodeId) as FormulaNode\n    draftNode.forest = [makeContradictionNode(draftNode.id)]\n  }\n\n  markFinished(nodeId: string) {\n    const draftNode = getNode(this.draftState.tree, nodeId) as FormulaNode\n    draftNode.forest = [makeFinishedNode(nodeId)]\n  }\n\n  reopenBranch(nodeId: string) {\n    const draftNode = getNode(this.draftState.tree, nodeId) as FormulaNode\n    draftNode.forest = []\n  }\n}\n\nexport const initialPremises = 'P->Q,P,~Q'\nconst premiseArray = initialPremises.split(',')\n\nexport const initialState: RudolfStore = {\n  tree: parsePremises(premiseArray),\n  nextRow: premiseArray.length + 1,\n  justifications: { 1: { rule: 'AS', parentRow: '' } },\n  feedback: { errorMessage: 'Nothing yet.' },\n}\n\nexport const rudolfReducer = createReducerFunction(RudolfReducer)\nexport const {\n  continueBranch,\n  createTree,\n  markContradiction,\n  markFinished,\n  reopenBranch,\n  splitBranch,\n  toggleResolved,\n  updateContradiction,\n  updateFeedback,\n  updateFormula,\n  updateJustification,\n} = createActionCreators(RudolfReducer)\nexport type RudolfAction = Actions<typeof RudolfReducer>\nexport type CustomDispatch = Dispatch<RudolfAction>\n","import { Menu, MenuItem } from '@material-ui/core'\nimport React, { FC } from 'react'\n\nimport {\n  CustomDispatch,\n  toggleResolved,\n  continueBranch,\n  splitBranch,\n  markContradiction,\n  markFinished,\n  reopenBranch,\n} from '../RudolfReducer'\nimport { TreeNode } from '../typings/TreeState'\nimport { isOpenLeaf } from '../util/nodes'\n\ntype Props = {\n  onClose: () => void\n  open: boolean\n  index: number\n  node: TreeNode\n  anchorEl: Element\n  dispatch: CustomDispatch\n}\n\n/**\n * @TODO make context menu work for each of\n * - Formula Node:\n *   - branch commands\n *\n * - Contradiction/Finished node:\n *   - Reopen.\n * - Formula:\n *   - branch commands\n *   - (un)resolve\n *   - close branch.\n */\n\nexport const NodeMenu: FC<Props> = ({\n  open,\n  dispatch,\n  index,\n  anchorEl,\n  onClose: close,\n  node,\n}) => {\n  const formula = node.formulas[index]\n  return (\n    <Menu open={open} anchorEl={anchorEl} onClose={close}>\n      <MenuItem\n        onClick={() => {\n          dispatch(continueBranch(node.id, 1))\n          close()\n        }}\n      >\n        Continue Branch w/ 1 formula\n      </MenuItem>\n      <MenuItem\n        onClick={() => {\n          dispatch(splitBranch(node.id, 1))\n          close()\n        }}\n      >\n        Split Branch w/ 1 formula\n      </MenuItem>\n      <MenuItem\n        onClick={() => {\n          dispatch(continueBranch(node.id, 2))\n          close()\n        }}\n      >\n        Continue Branch w/ 2 formulas\n      </MenuItem>\n      <MenuItem\n        onClick={() => {\n          dispatch(splitBranch(node.id, 2))\n          close()\n        }}\n      >\n        Split Branch w/ 2 formulas\n      </MenuItem>\n      <MenuItem\n        onClick={() => {\n          dispatch(toggleResolved(node.id, index))\n          close()\n        }}\n      >\n        Mark as {formula.resolved ? 'Un' : ''}Resolved\n      </MenuItem>\n      {isOpenLeaf(node) && (\n        <MenuItem\n          onClick={() => {\n            dispatch(markContradiction(node.id))\n            close()\n          }}\n        >\n          Close Branch With Contradiction\n        </MenuItem>\n      )}\n      {isOpenLeaf(node) && (\n        <MenuItem\n          onClick={() => {\n            dispatch(markFinished(node.id))\n            close()\n          }}\n        >\n          Mark Branch Finished\n        </MenuItem>\n      )}\n      {node.nodeType === 'contradiction' && (\n        <MenuItem\n          onClick={() => {\n            dispatch(reopenBranch(node.id))\n            close()\n          }}\n        >\n          Reopen Branch\n        </MenuItem>\n      )}\n    </Menu>\n  )\n}\n","import React, { FC, useState, useRef, Ref } from 'react'\nimport { Check } from '@material-ui/icons'\nimport { CustomDispatch, updateFormula } from '../RudolfReducer'\nimport { NodeMenu } from './NodeMenu'\nimport { FormulaNode } from '../typings/TreeState'\n\ninterface Props {\n  row: number\n  value: string\n  resolved: boolean\n  node: FormulaNode\n  index: number\n  dispatch: CustomDispatch\n}\n\nconst FormulaView: FC<Props> = ({ index, row, dispatch, node }) => {\n  const formula = node.formulas[index]\n  const { value, resolved } = formula\n  const [contextMenu, setContextMenu] = useState(false) // Convert to reducer action/field w/ ref, node, optional index.\n  const ref: Ref<HTMLDivElement> = useRef(null)\n  return (\n    <div\n      className=\"formula node\"\n      ref={ref}\n      onContextMenu={(e) => {\n        e.preventDefault()\n        setContextMenu(true)\n      }}\n    >\n      <span>{row}</span>\n      <input\n        className=\"label\"\n        onChange={(event) =>\n          dispatch(updateFormula(node.id, index, event.currentTarget.value))\n        }\n        value={value}\n        placeholder=\"formula\"\n      />\n      <NodeMenu\n        open={contextMenu}\n        onClose={() => setContextMenu(false)}\n        dispatch={dispatch}\n        anchorEl={ref.current as HTMLDivElement}\n        index={index}\n        node={node}\n      />\n      {resolved ? <Check /> : ''}\n    </div>\n  )\n}\n\nexport default FormulaView\n","import React from 'react'\n\nconst Spacers = ({ diff }: { diff: number }) => {\n  const spacers: JSX.Element[] = []\n  const i = diff\n  while (spacers.length < i) {\n    spacers.push(<div className=\"spacer\" key={i} />)\n  }\n\n  return <div className={`spacers-${diff}`}>{spacers}</div>\n}\n\nexport default Spacers\n","/* eslint-disable react/jsx-no-undef */\nimport React, { FC, Fragment } from 'react'\nimport LineTo from 'react-lineto'\nimport AutoSizeInput from 'react-input-autosize'\nimport { TreeNode } from '../typings/TreeState'\nimport FormulaView from './FormulaView'\nimport {\n  CustomDispatch,\n  updateContradiction,\n  updateJustification,\n  RudolfStore,\n} from '../RudolfReducer'\nimport { lastRow, firstRow, isFormulaNode } from '../util/nodes'\nimport Spacers from './Spacers'\n\ntype Props = {\n  node: TreeNode\n  dispatch: CustomDispatch\n  store: RudolfStore\n}\n\nconst NodeView: FC<Props> = ({ node, dispatch, store }) => {\n  if (isFormulaNode(node)) {\n    const { id, formulas, forest } = node\n\n    const spacers =\n      forest[0]?.nodeType === 'formulas' ? (\n        <Spacers diff={firstRow(forest[0]) - lastRow(node)} />\n      ) : undefined\n\n    const { rule, parentRow } = store.justifications[firstRow(node)]\n    return (\n      <div className={`node-container `}>\n        <div\n          className={`node-id=${id}`}\n          // TODO: allow context menu on nodes?\n          // onContextMenu={handleContextMenu}\n        >\n          {formulas.map((form, index) => {\n            return (\n              <FormulaView\n                key={`${form}-${index}`}\n                node={node}\n                index={index}\n                dispatch={dispatch}\n                row={form.row}\n                {...form}\n              />\n            )\n          })}\n          {node.id !== '' ? (\n            <div className=\"justification\">\n              <AutoSizeInput\n                className=\"rule\"\n                onChange={({ currentTarget: { value: rule } }) =>\n                  dispatch(updateJustification(firstRow(node), { rule }))\n                }\n                value={rule}\n                placeholder=\"rule\"\n              />\n              <AutoSizeInput\n                className=\"row\"\n                onChange={({ currentTarget: { value: parentRow } }) =>\n                  dispatch(updateJustification(firstRow(node), { parentRow }))\n                }\n                value={parentRow}\n                placeholder=\"row\"\n              />\n            </div>\n          ) : (\n            'AS'\n          )}\n        </div>\n\n        <div className={`children ${forest.length > 1 ? 'split' : 'stack'}`}>\n          {forest.map((child) => {\n            return (\n              <Fragment key={child.id}>\n                {spacers}\n                <LineTo\n                  from={`node-id=${id}`}\n                  to={`node-id=${child.id}`}\n                  borderColor=\"black\"\n                  fromAnchor=\"bottom\"\n                  toAnchor=\"top\"\n                  delay={0}\n                />\n                <NodeView\n                  {...{\n                    node: child,\n                    dispatch,\n                    store,\n                  }}\n                />\n              </Fragment>\n            )\n          })}\n        </div>\n      </div>\n    )\n  } else if (node.nodeType === 'contradiction') {\n    return (\n      <div className=\"closed-branch-marker\">\n        X\n        <AutoSizeInput\n          className=\"rule\"\n          onChange={({ currentTarget: { value } }) =>\n            dispatch(updateContradiction(node.id, value))\n          }\n          value={node.contradictoryRows}\n          placeholder=\"rows\"\n        />\n      </div>\n    )\n  } else if (node.nodeType === 'finished') {\n    return <div className=\"finished-branch-marker\">O </div>\n  } else {\n    throw new Error(\n      `Invariant violation: Invalid nodeType on node: ${JSON.stringify(node)}`\n    )\n  }\n}\n\nexport default NodeView\n","import React, { FormEventHandler } from 'react'\nimport AutosizeInput from 'react-input-autosize'\n\ntype Props = {\n  onSubmit: (premises: string) => void\n  premises: string\n  setPremises: (premises: string) => void\n}\n\nconst PremiseInput: React.FC<Props> = ({ onSubmit, premises, setPremises }) => {\n  const handleSubmit: FormEventHandler<HTMLFormElement> = (event) => {\n    event.preventDefault()\n    onSubmit(premises)\n  }\n  return (\n    <form onSubmit={handleSubmit}>\n      <AutosizeInput\n        type=\"text\"\n        name=\"premises\"\n        aria-label=\"Enter Premises\"\n        value={premises}\n        onChange={(event) => setPremises(event.target.value)}\n      />\n      <button className=\"submit-premises\" type=\"submit\">\n        Declare Premises\n      </button>\n    </form>\n  )\n}\n\nexport default PremiseInput\n","import React, { ChangeEventHandler } from 'react'\n\ntype Props = {\n  onChange: (premises: string) => void\n}\n\nconst examples = [\n  ['P->Q,P,~Q', 'Modus Ponens'],\n  ['~(~(P\\\\/Q)<->(~P/\\\\~Q))', \"De Morgen's Law\"],\n]\n\nconst PremisesSelector: React.FC<Props> = ({ onChange }) => {\n  const handleSelect: ChangeEventHandler<HTMLSelectElement> = (event) => {\n    const premises: string = event.currentTarget.value\n    onChange(premises)\n  }\n\n  return (\n    <select onChange={handleSelect}>\n      {examples.map(([value, name]) => (\n        <option value={value} key={value}>\n          {name}\n        </option>\n      ))}\n    </select>\n  )\n}\n\nexport default PremisesSelector\n","import { FormulaNode, TreeForm, JustificationMap } from '../typings/TreeState'\nimport { firstRow } from './nodes'\nimport { SequentNode } from '../typings/Checker'\n\nexport const convertToSequent = (\n  { formulas: newFormulas, forest }: FormulaNode,\n  justifications: JustificationMap,\n  previousFormulas: TreeForm[] = []\n): SequentNode => {\n  const formulas = previousFormulas.concat(newFormulas)\n  if (forest.length === 0) {\n    return { label: convertFormulas(formulas), rule: '', forest: [] }\n  } else {\n    const [child] = forest\n    if (child.nodeType === 'formulas') {\n      const justification = justifications[firstRow(child)]\n      const { rule } = justification\n      const parentRow = Number(justification.parentRow)\n      if (!validRow(parentRow)) {\n        throw new Error(\n          `Cited row must be a positive integer. Got \"${parentRow}\"`\n        )\n      }\n      if (parentRow >= firstRow(child)) {\n        throw new Error(\n          `Row cited (${parentRow}) must be less than current row (${firstRow(\n            child\n          )}).`\n        )\n      }\n      return {\n        label: convertFormulas(formulas),\n        rule: 'St',\n        forest: [\n          {\n            label: rearrangeFormulas(formulas, parentRow),\n            rule,\n            forest: forest.map((node) =>\n              convertToSequent(\n                node as FormulaNode,\n                justifications,\n                formulas.filter((form) => !(form.row === parentRow))\n              )\n            ),\n          },\n        ],\n      }\n    } else if (child.nodeType === 'contradiction') {\n      // We expect parentRow to be \"<number>,<number>\"\n      const [row1, row2] = child.contradictoryRows.split(',').map(Number)\n      if (![row1, row2].every(validRow)) {\n        throw new Error(\n          `Contradiction must cite 2 rows, separated by a comma. Got \"${child.contradictoryRows}\"`\n        )\n      }\n      const [form1, form2] = formulas\n        .filter((form) => [row1, row2].includes(form.row))\n        // this sort is a hack to avoid parsing for negation symbol, which may vary\n        .sort((a, b) => b.value.length - a.value.length)\n      if (!(form1 && form2)) {\n        throw new Error('Contradiction cites non-existent row')\n      }\n      const contradictionSequent: string = convertFormulas([\n        form1,\n        ...formulas.filter((form) => ![row1, row2].includes(form.row)),\n        form2,\n      ])\n      return {\n        label: convertFormulas(formulas),\n        rule: 'St',\n        forest: [\n          {\n            label: contradictionSequent,\n            rule: 'Ax',\n            forest: [{ label: '', rule: '', forest: [] }],\n          },\n        ],\n      }\n    } else if (child.nodeType === 'finished') {\n      return {\n        label: convertFormulas(formulas),\n        rule: 'Lit',\n        forest: [\n          {\n            label: '',\n            rule: '',\n            forest: [],\n          },\n        ],\n      }\n    } else {\n      throw new Error('this was supposed to be exhaustive')\n    }\n  }\n}\n\nconst rearrangeFormulas = (\n  forms: TreeForm[],\n  mainFormulaRow: number\n): string => {\n  const idx = forms.findIndex((form) => form.row === mainFormulaRow)\n  const mainFormula = forms[idx]\n  const formulasWithoutMain = forms.slice(0, idx).concat(forms.slice(idx + 1))\n  const newList = [...formulasWithoutMain, mainFormula]\n  return convertFormulas(newList)\n}\n\nconst convertFormulas = (forms: TreeForm[]) => {\n  return forms\n    .map(({ value }) => value)\n    .join(',')\n    .concat(':|-:')\n}\n\nconst validRow = (maybeRow: number): boolean => {\n  return maybeRow > 0\n}\n","import { TextareaAutosize } from '@material-ui/core'\nimport React, { FC, useEffect } from 'react'\n\nimport { RudolfStore, updateFeedback, CustomDispatch } from '../RudolfReducer'\nimport { SequentNode, FeedbackNode, CheckerFeedback } from '../typings/Checker'\nimport { JustificationMap } from '../typings/TreeState'\nimport { convertToSequent } from '../util/carnapAdapter'\n\nexport const checkSequent = async (\n  sequent: SequentNode\n): Promise<FeedbackNode> => {\n  return new Promise((resolve, reject) => {\n    try {\n      window.Carnap.checkIchikawaJenkinsSLTableau(\n        sequent,\n        (result: FeedbackNode) => {\n          resolve(result)\n        }\n      )\n    } catch (error) {\n      reject(error)\n    }\n  })\n}\n\nconst checkTree = async (\n  tree: any,\n  justifications: JustificationMap\n): Promise<CheckerFeedback> => {\n  const sequent = convertToSequent(tree, justifications)\n  const feedbackTree: FeedbackNode = await checkSequent(sequent)\n  return { sequent, feedbackTree }\n}\nexport const JSONView: FC<RudolfStore & { dispatch: CustomDispatch }> = ({\n  tree,\n  justifications,\n  feedback,\n  dispatch,\n}) => {\n  useEffect(() => {\n    if (window.Carnap) {\n      checkTree(tree, justifications)\n        .then((res: CheckerFeedback) => {\n          return dispatch(updateFeedback(res))\n        })\n        .catch(({ message }: Error) => {\n          return dispatch(updateFeedback({ errorMessage: message }))\n        })\n    }\n  }, [dispatch, justifications, tree])\n  return (\n    <TextareaAutosize\n      className=\"json-view\"\n      value={JSON.stringify({ tree, justifications, feedback })}\n      style={{\n        overflow: 'hidden scroll',\n        fontSize: '16px',\n        minWidth: '100%',\n        position: 'fixed',\n        bottom: 0,\n        maxHeight: '50%',\n      }}\n    />\n  )\n}\n","import React, { useState, useReducer } from 'react'\n\nimport NodeView from './NodeView'\nimport PremiseInput from './PremiseInput'\nimport PremisesSelector from './PremisesSelector'\nimport { IconButton } from '@material-ui/core'\nimport { Undo, Redo } from '@material-ui/icons'\nimport {\n  initialPremises,\n  initialState,\n  rudolfReducer,\n  createTree,\n} from '../RudolfReducer'\nimport { makeUndoable } from '../undoableReducer'\nimport { JSONView } from './JSONView'\n\nconst App: React.FC = (): JSX.Element => {\n  const [premises, setPremises] = useState(initialPremises)\n  const [[pastStates, currentState, futureStates], dispatch] = useReducer(\n    ...makeUndoable(rudolfReducer, initialState)\n  )\n\n  const handleSubmitPremises = (rawInput: string) => {\n    setPremises(rawInput)\n    const premiseArray = rawInput.split(',')\n    dispatch(createTree(premiseArray))\n  }\n\n  return (\n    <main className=\"App\">\n      <PremisesSelector onChange={handleSubmitPremises} />\n      <PremiseInput\n        premises={premises}\n        onSubmit={handleSubmitPremises}\n        setPremises={setPremises}\n      />\n      <span className=\"tree-buttons\">\n        <IconButton\n          className=\"undo-button\"\n          onClick={() => {\n            dispatch({ type: 'UNDO' })\n          }}\n          disabled={!pastStates.length}\n        >\n          <Undo />\n        </IconButton>\n        <IconButton\n          className=\"redo-button\"\n          onClick={() => {\n            dispatch({ type: 'REDO' })\n          }}\n          disabled={!futureStates.length}\n        >\n          <Redo />\n        </IconButton>\n      </span>\n      <NodeView\n        node={currentState.tree}\n        dispatch={dispatch}\n        store={currentState}\n      />\n      <JSONView {...{ ...currentState, dispatch }} />\n    </main>\n  )\n}\n\nexport default App\n","import { Reducer } from 'react'\n\ntype TrackedChanges<S> = [S[], S, S[]]\n\nexport const makeUndoable = <S, A extends { type: string }>(\n  innerReducer: Reducer<S, A>,\n  initialState: S\n): [\n  Reducer<TrackedChanges<S>, A | { type: 'UNDO' } | { type: 'REDO' }>,\n  TrackedChanges<S>\n] => [\n  (\n    [past, present, future]: [S[], S, S[]],\n    action: A | { type: 'UNDO' } | { type: 'REDO' }\n  ) => {\n    switch (action.type) {\n      case 'UNDO':\n        const [previous, ...ancientHistory] = past\n        return [ancientHistory, previous, [present, ...future]]\n      case 'REDO':\n        const [next, ...distantFuture] = future\n        return [[present, ...past], next, distantFuture]\n      default:\n        return [[present, ...past], innerReducer(present, action as A), []]\n    }\n  },\n  [[], initialState, []],\n]\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n)\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void\n  onUpdate?: (registration: ServiceWorkerRegistration) => void\n}\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    )\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config)\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          )\n        })\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config)\n      }\n    })\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing\n        if (installingWorker == null) {\n          return\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              )\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration)\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.')\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration)\n              }\n            }\n          }\n        }\n      }\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error)\n    })\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type')\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload()\n          })\n        })\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config)\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.')\n    })\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister()\n    })\n  }\n}\n","import 'bootstrap/dist/css/bootstrap.min.css'\nimport './styles/_main.scss'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport App from './components/App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}